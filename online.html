<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Aurora Point | Ultra Professional Multiplayer</title>
    
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-firestore.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/nipplejs@0.9.1/dist/nipplejs.min.js"></script>

    <style>
        :root { --primary: #00f2ff; --bg: #000810; }
        body { margin: 0; overflow: hidden; background: var(--bg); touch-action: none; font-family: 'JetBrains Mono', monospace; }
        #loading-screen { position: fixed; inset: 0; background: radial-gradient(circle at center, #001a33 0%, #000 100%); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 10000; }
        .scanline { width: 100%; height: 100%; position: absolute; background: linear-gradient(to bottom, rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06)); background-size: 100% 2px, 3px 100%; pointer-events: none; }
        .loading-text { font-size: 2rem; color: var(--primary); text-shadow: 0 0 10px var(--primary); margin-bottom: 10px; font-weight: bold; }
        .bar-container { width: 300px; height: 4px; background: rgba(255,255,255,0.05); border-radius: 2px; position: relative; overflow: hidden; border: 1px solid rgba(0, 242, 255, 0.2); }
        #progress-fill { position: absolute; left: 0; top: 0; height: 100%; background: var(--primary); box-shadow: 0 0 15px var(--primary); transition: width 0.5s cubic-bezier(0.4, 0, 0.2, 1); }
        #game-hud { position: fixed; inset: 0; pointer-events: none; opacity: 0; transition: opacity 1s; }
        #joystick-zone { position: absolute; bottom: 40px; left: 40px; width: 140px; height: 140px; pointer-events: auto; }
        #jump-btn { position: absolute; bottom: 60px; right: 50px; width: 80px; height: 80px; background: rgba(0, 242, 255, 0.1); border: 2px solid var(--primary); border-radius: 50%; pointer-events: auto; color: white; display: flex; align-items: center; justify-content: center; font-weight: bold; backdrop-filter: blur(5px); box-shadow: 0 0 20px rgba(0, 242, 255, 0.2); }
        .stats-overlay { position: absolute; top: 20px; right: 20px; color: var(--primary); font-size: 10px; text-align: right; pointer-events: none; }
        .exit-btn { position: absolute; top: 20px; left: 20px; pointer-events: auto; background: none; border: 1px solid red; color: red; padding: 5px 15px; cursor: pointer; border-radius: 3px; }
    </style>
</head>
<body>

    <div id="loading-screen">
        <div class="scanline"></div>
        <div class="loading-text" id="percent-num">0%</div>
        <div class="bar-container"><div id="progress-fill"></div></div>
        <div id="status-text" style="color: rgba(255,255,255,0.5); font-size: 9px; margin-top: 10px;">BOOTING KERNEL...</div>
    </div>

    <div id="game-hud">
        <div class="stats-overlay" id="network-stats">PING: --ms | PLAYERS: 0</div>
        <div id="joystick-zone"></div>
        <div id="jump-btn">JUMP</div>
        <button class="exit-btn" onclick="exitGame()">DISCONNECT</button>
    </div>

    <script>
        const Config = {
            firebase: {
                apiKey: "AIzaSyBvwC0_9DREMFIHFelYuc5RdfXz6bpo1JA",
                authDomain: "aurorapoint-a8a1e.firebaseapp.com",
                projectId: "aurorapoint-a8a1e",
                storageBucket: "aurorapoint-a8a1e.firebasestorage.app",
                messagingSenderId: "324340380415",
                appId: "1:324340380415:web:468fcca5188b539682d2ca"
            },
            physics: { gravity: -35, jumpForce: 16, walkSpeed: 13, lerpFactor: 0.18 },
            network: { tickRate: 100 },
            economy: { rewardInterval: 30000 }
        };

        class AuroraEngine {
            constructor() {
                this.scene = null; this.camera = null; this.renderer = null; this.world = null;
                this.player = { body: null, mesh: null, id: null, username: "Guest" };
                this.entities = new Map();
                this.input = { x: 0, z: 0 };
                this.camRotation = { theta: 0, phi: 0.6 }; 
                this.camDistance = 18;
                this.touchStart = { x: 0, y: 0 };
            }

            async init() {
                try {
                    this.updateProgress(10, "FIREBASE_SYNC");
                    if (!firebase.apps.length) firebase.initializeApp(Config.firebase);
                    const user = await this.getAuth();
                    this.player.id = user.uid;

                    const doc = await firebase.firestore().collection("users").doc(this.player.id).get();
                    this.player.data = doc.exists ? doc.data() : { avatar: {}, username: "Player" };
                    this.player.username = this.player.data.username || "Player";

                    this.setupGraphics();
                    this.setupPhysics();
                    this.loadMap();
                    this.setupRewardSystem();
                    this.setupNetwork();
                    this.setupControls();

                    this.updateProgress(100, "SYSTEM_ONLINE");
                    this.startLoop();
                } catch (e) { console.error(e); }
            }

            loadMap() {
                const loader = new THREE.GLTFLoader();
                loader.load('crossroads.glb', (gltf) => {
                    const model = gltf.scene;
                    model.scale.set(2.5, 2.5, 2.5); 
                    model.position.set(0, -1.6, 0); 
                    model.traverse(n => {
                        if (n.isMesh) {
                            n.castShadow = true;
                            n.receiveShadow = true;
                            if(n.material) {
                                n.material.metalness = 0;
                                n.material.roughness = 0.8;
                            }
                        }
                    });
                    this.scene.add(model);
                }, (xhr) => {
                    let p = Math.round((xhr.loaded / xhr.total) * 100);
                    this.updateProgress(85 + (p/10), "GEOMETRY_SYNC_" + p + "%");
                });
            }

            setupGraphics() {
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x000205);
                this.scene.fog = new THREE.Fog(0x000205, 30, 200);
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 2000);
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.outputEncoding = THREE.sRGBEncoding;
                document.body.appendChild(this.renderer.domElement);
                this.scene.add(new THREE.AmbientLight(0xffffff, 1.0));
                this.scene.add(new THREE.HemisphereLight(0x00f2ff, 0x000000, 0.6));
                const sun = new THREE.DirectionalLight(0xffffff, 1.2);
                sun.position.set(20, 100, 20);
                this.scene.add(sun);
                const grid = new THREE.GridHelper(500, 50, 0x00f2ff, 0x111111);
                grid.position.y = -1.61;
                this.scene.add(grid);
            }

            setupPhysics() {
                this.world = new CANNON.World();
                this.world.gravity.set(0, Config.physics.gravity, 0);
                const groundBody = new CANNON.Body({ mass: 0 });
                groundBody.addShape(new CANNON.Plane());
                groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1,0,0), -Math.PI/2);
                groundBody.position.y = -1.6; 
                this.world.addBody(groundBody);
                this.player.body = new CANNON.Body({ 
                    mass: 1.5, 
                    shape: new CANNON.Box(new CANNON.Vec3(0.5, 1.5, 0.4)), 
                    position: new CANNON.Vec3(0, 8, 0),
                    fixedRotation: true 
                });
                this.world.addBody(this.player.body);
                this.player.mesh = this.createR6Model(this.player.data.avatar, this.player.username);
                this.scene.add(this.player.mesh);
            }

            createR6Model(colors = {}, name) {
                const group = new THREE.Group();
                const parts = {};
                const mat = (c) => new THREE.MeshPhongMaterial({ color: c || 0x00f2ff });
                const add = (w,h,d, x,y,z, id) => {
                    const m = new THREE.Mesh(new THREE.BoxGeometry(w,h,d), mat(colors[id]));
                    m.position.set(x,y,z); group.add(m); parts[id] = m;
                };
                add(0.6,0.6,0.6, 0,1.3,0, 'body-head');
                add(0.9,1.2,0.5, 0,0.4,0, 'body-torso');
                add(0.4,1.1,0.4, -0.7,0.4,0, 'body-larm');
                add(0.4,1.1,0.4, 0.7,0.4,0, 'body-rarm');
                add(0.45,1.1,0.45, -0.25,-0.8,0, 'body-lleg');
                add(0.45,1.1,0.45, 0.25,-0.8,0, 'body-rleg');
                group.userData.parts = parts;
                return group;
            }

            setupControls() {
                const joy = nipplejs.create({ zone: document.getElementById('joystick-zone'), mode: 'static', position: {left: '70px', bottom: '70px'}, color: '#00f2ff' });
                joy.on('move', (e, d) => {
                    const moveAngle = d.angle.radian + this.camRotation.theta;
                    this.input.x = Math.cos(moveAngle) * Config.physics.walkSpeed * (d.distance / 50);
                    this.input.z = -Math.sin(moveAngle) * Config.physics.walkSpeed * (d.distance / 50);
                });
                joy.on('end', () => { this.input.x = 0; this.input.z = 0; });
                document.getElementById('jump-btn').addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if(Math.abs(this.player.body.velocity.y) < 0.5) this.player.body.velocity.y = Config.physics.jumpForce;
                });
                window.addEventListener('touchstart', (e) => {
                    if (e.target.closest('#joystick-zone') || e.target.closest('#jump-btn')) return;
                    this.touchStart.x = e.touches[0].pageX; this.touchStart.y = e.touches[0].pageY;
                });
                window.addEventListener('touchmove', (e) => {
                    if (e.target.closest('#joystick-zone') || e.target.closest('#jump-btn')) return;
                    const dx = e.touches[0].pageX - this.touchStart.x;
                    const dy = e.touches[0].pageY - this.touchStart.y;
                    this.camRotation.theta -= dx * 0.008;
                    this.camRotation.phi = Math.max(0.1, Math.min(1.4, this.camRotation.phi + dy * 0.008));
                    this.touchStart.x = e.touches[0].pageX; this.touchStart.y = e.touches[0].pageY;
                });
            }

            startLoop() {
                const animate = () => {
                    requestAnimationFrame(animate);
                    this.world.step(1/60);
                    this.player.mesh.position.copy(this.player.body.position);
                    this.player.body.velocity.x = this.input.x;
                    this.player.body.velocity.z = this.input.z;

                    const cx = this.player.mesh.position.x + this.camDistance * Math.sin(this.camRotation.theta) * Math.cos(this.camRotation.phi);
                    const cy = this.player.mesh.position.y + this.camDistance * Math.sin(this.camRotation.phi);
                    const cz = this.player.mesh.position.z + this.camDistance * Math.cos(this.camRotation.theta) * Math.cos(this.camRotation.phi);
                    this.camera.position.set(cx, cy, cz);
                    this.camera.lookAt(this.player.mesh.position.x, this.player.mesh.position.y + 1, this.player.mesh.position.z);

                    if(Math.abs(this.input.x) > 0.1 || Math.abs(this.input.z) > 0.1) {
                        this.player.mesh.rotation.y = this.lerpAngle(this.player.mesh.rotation.y, Math.atan2(this.input.x, this.input.z), 0.2);
                        this.animateWalking(this.player.mesh, true);
                    } else {
                        this.animateWalking(this.player.mesh, false);
                    }

                    // SINCRONIA SUAVE DOS OUTROS JOGADORES
                    this.entities.forEach(ent => {
                        if(ent.userData.targetPos) {
                            ent.position.lerp(ent.userData.targetPos, 0.2);
                            ent.rotation.y = this.lerpAngle(ent.rotation.y, ent.userData.targetRot, 0.2);
                            this.animateWalking(ent, ent.position.distanceTo(ent.userData.targetPos) > 0.1);
                        }
                    });

                    this.renderer.render(this.scene, this.camera);
                };
                animate();
            }

            lerpAngle(a, b, t) {
                let d = b - a;
                while (d < -Math.PI) d += Math.PI * 2;
                while (d > Math.PI) d -= Math.PI * 2;
                return a + d * t;
            }

            animateWalking(mesh, active) {
                const t = Date.now() * 0.012;
                const p = mesh.userData.parts;
                if(active && p) {
                    p['body-lleg'].rotation.x = Math.sin(t)*0.7; p['body-rleg'].rotation.x = -Math.sin(t)*0.7;
                    p['body-larm'].rotation.x = -Math.sin(t)*0.5; p['body-rarm'].rotation.x = Math.sin(t)*0.5;
                } else if(p) {
                    Object.values(p).forEach(part => part.rotation.x = THREE.MathUtils.lerp(part.rotation.x, 0, 0.1));
                }
            }

            setupNetwork() {
                const col = firebase.firestore().collection("online_players");
                
                // Envio de posição unificado (X, Y, Z)
                setInterval(() => {
                    col.doc(this.player.id).set({
                        name: this.player.username,
                        avatar: this.player.data.avatar || {},
                        x: this.player.body.position.x,
                        y: this.player.body.position.y,
                        z: this.player.body.position.z,
                        ry: this.player.mesh.rotation.y,
                        lastSeen: firebase.firestore.FieldValue.serverTimestamp()
                    }, { merge: true });
                }, Config.network.tickRate);

                col.onSnapshot(snap => {
                    snap.docChanges().forEach(change => {
                        const id = change.doc.id; if(id === this.player.id) return;
                        const data = change.doc.data();
                        if(change.type === "added") {
                            const ent = this.createR6Model(data.avatar, data.name);
                            ent.userData.targetPos = new THREE.Vector3(data.x, data.y, data.z);
                            ent.userData.targetRot = data.ry || 0;
                            this.scene.add(ent); this.entities.set(id, ent);
                        }
                        if(change.type === "modified") {
                            const ent = this.entities.get(id);
                            if(ent) {
                                ent.userData.targetPos.set(data.x, data.y, data.z);
                                ent.userData.targetRot = data.ry || 0;
                            }
                        }
                        if(change.type === "removed") {
                            const ent = this.entities.get(id);
                            if(ent) { this.scene.remove(ent); this.entities.delete(id); }
                        }
                    });
                    document.getElementById('network-stats').innerText = `PLAYERS: ${this.entities.size + 1}`;
                });
            }

            setupRewardSystem() {
                setInterval(async () => {
                    if (!this.player.id) return;
                    const ref = firebase.firestore().collection("users").doc(this.player.id);
                    try {
                        await firebase.firestore().runTransaction(async (t) => {
                            const d = await t.get(ref);
                            if (d.exists) t.update(ref, { tixs: (d.data().tixs || 0) + 1 });
                            this.showNotification(`+1 TIX RECEBIDO!`);
                        });
                    } catch (e) {}
                }, Config.economy.rewardInterval);
            }

            showNotification(msg) {
                const n = document.createElement('div');
                n.style.cssText = `position: fixed; top: 80px; left: 50%; transform: translateX(-50%); background: rgba(0, 242, 255, 0.2); color: #00f2ff; padding: 12px 30px; border-radius: 20px; border: 1px solid #00f2ff; font-family: monospace; z-index: 10000; animation: slideDown 0.5s;`;
                n.innerText = msg; document.body.appendChild(n); setTimeout(() => n.remove(), 3000);
            }

            getAuth() { return new Promise(res => firebase.auth().onAuthStateChanged(u => u ? res(u) : window.location.href='index.html')); }
            updateProgress(v, t) {
                document.getElementById('progress-fill').style.width = v + "%";
                document.getElementById('percent-num').innerText = v + "%";
                document.getElementById('status-text').innerText = t;
                if(v >= 100) setTimeout(() => { document.getElementById('loading-screen').style.display = "none"; document.getElementById('game-hud').style.opacity = "1"; }, 1000);
            }
        }

        async function exitGame() {
            if (firebase.auth().currentUser) {
                await firebase.firestore().collection("online_players").doc(firebase.auth().currentUser.uid).delete();
            }
            window.location.replace('home.html');
        }

        const Game = new AuroraEngine();
        window.onload = () => Game.init();
    </script>
</body>
</html>
